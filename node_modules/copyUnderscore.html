<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<title>undescore</title>
</head>
<body>
	第一遍按源码敲
<script>
	;(function(){
//		console.log(this);
//		root 获得全局变量
		var root = this;
//		保存全局环境下的_ 变量,到时候进行复制
		var previousUnderscore = root._;
//		console.log(previousUnderscore);
//实现更少的字节和作用域链查找   (可以再浏览数上看原型上有什么内置的方法)
		var ArrayProto = Array.prototype,
			ObjProto = Object.prototype,
			FuncProto = Function.prototype;

		var push = ArrayProto.push,
			slice = ArrayProto.slice,
			toString = ObjProto.toString,
			hasOwnProperty = ObjProto.hasOwnProperty;
//		ECMAScript 5 的原生方法  keys? bind?
		var nativeIsArray = Array.isArray,
			nativeKeys = Object.keys,
			nativeBind = FuncProto.bind,
			nativeCreate = Object.create;
		
//  https://msdn.microsoft.com/zh-cn/library/ff841995(v=vs.94).aspx	
	//	eg  keys 返回对象的可枚举属性和方法的名称      ☆
/*		function getAtrrbute(name,age,index){
			this.name = name,
			this.age = age,
			this.index = index;
			this.getName = function(){
				return this.name;
			}
		}
		var newObj = new getAtrrbute('sm',10,101);
		var arrNum = Object.keys(newObj);
	//	output:
	//		["name", "age", "index", "getName"]
		console.log(arrNum);   */
	
	//  eg  bind 
//对于给定函数，创建具有与原始函数相同的主体的绑定函数。在绑定函数中，this 对象将解析为传入的对象。绑定函数具有指定的初始参数。	
	
	
		//裸体的  Naked 空函数
 		var Ctor = function(){};
// 		暴露_接口
 		var _= function(obj){
 			console.log(this);
 			if(obj instanceof _) return obj;
 			if(!(this instanceof _))return new _(obj);
 			this._wrapped = obj;
 		};
// 		undefined 是string形式的    node.js 扩展
 		if(typeof exports !== 'undefined'){
 			if(typeof module !== 'undefined' && module.exports){
 				exports = module.exports = _;
 			}
 			exports._ = _;
 		}else{
 			root._ = _;
 		}
 		
 		_.VERSION = '1遍';

//??  call apply  
		var optimizeCb = function(func,context,argCount){
			if(context === void 0) return func;
			switch(argCount ==null ?3:argCount){
				case 1:return function(value){
					return func.call(context,value);
				};
				case 2:return function(value,other){
					return func.call(context,value,other);
				};
				case 3: return function (value,index,collection){
					return func.call(context,value,index,collection);
					
				};
				case 4: return function(accumulator,value,index,collection){
					return func.call(context,accumulator,value,index,collection);
				};
			}
			return function(){
				return func.apply(context,arguments);
			};
		};

		var cb = function(value,context,argCount){
			if(value ==null) return _.identity;
			if(_.isFuncion(value))return optimizeCb(value,context,argCount);
			if(_.isObject(value))return _.matcher(value);
			return _.property(value);
		}
		_.iteratee = function(value,context){
			return cb(value,context,Infinity);
		}

	// 	内部函数指定
 		var createAssigner = function(keysFunc,undefinedOnly){
 			return function(obj){
 				var length = arguments.length;
 				if(length<2 || obj ==null )return obj;
 				for(var index = 1;index<length;index++){
 					var source = arguments[index],
 						keys = keysFunc(source),
 						l = keys.length;
					for(var i=0;i<l;i++){
						var key = keys[i];
						if(!undefinedOnly || obj[key]=== void 0)obj[key]=source[key];
					}
 				}
 				return obj;
 			};
 		};
 		
	// 	创建新对象
 		var baseCreate = function(prototype){
 			if(!_.isObject(prototype))return {};
	// 	判断原型上有这个函数 (不支持则自己创建 )
 			if(nativeCreate) return nativeCreate(prototype);
 			Ctor.prototype = prototype;
 			var result = new Ctor;
 			Ctor.prototype = null;
 			return result;
 		};
// 		??  取属性
 		var property = function(key){
 			return function(obj){
 				return obj == null ? void 0 : obj[key];
 			};
 		};
 
//	返回true or false  isArrayLike()  通过length 属性来判断
 		var MAX_ARRAY_INDEX = Math.pow(2,53) -1;
 		var getLenth= property('length');
 		var isArrayLike = function(collection){
 			var length = getLength(collection);
 			return typeof length == 'number' && length>=0 && length<=MAX_ARRAY_INDEX;
 		};
 			
 		// Collection Functions  集合函数  
 		
// 		each foreach
 		_.each = _.forEach = function(obj,iteratee,context){
 			iteratee = optimizeCb(iteratee,context);
 			var i,length;
 			if(isArrayLike(obj)){
 				for(i=0,length=obj.length;i<length;i++){
 					iteratee(obj[i],i,obj);
 				}
 			}else{
 				var keys = _.keys(obj);
 				for(i=0,length=keys.length;i<length;i++){
 					iteratee(obj[keys[i]],keys[i],obj);
 				}
 			}
 			return obj;
 		};
 		
 		
 		
 		
	//	传入全局变量  window or node环境
	}.call(this));
</script>
</body>
</html>